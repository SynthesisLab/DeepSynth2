<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sharpening &mdash; ProgSynth 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Contributing to ProgSynth" href="contributing.html" />
    <link rel="prev" title="PBE Examples" href="examples_pbe.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ProgSynth
          </a>
              <div class="version">
                0.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage of ProgSynth</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="type_system.html">The Type System</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_pbe.html">PBE</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sharpening</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#forbidden-patterns">Forbidden Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simplifying-rules">Simplifying Rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#an-example">An Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatically-generated-equations">Automatically Generated Equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limits">Limits</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to ProgSynth</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ProgSynth</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Sharpening</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/sharpening.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sharpening">
<h1>Sharpening<a class="headerlink" href="#sharpening" title="Permalink to this heading"></a></h1>
<p>This submodule enables the sharpening of the grammars generated by ProgSynth reducing drastically their size.
Since ProgSynth tries to enumerate all programs from a grammar reducing its size is a relevant way to speed up the search, sharpening removes non relevant programs increasing the chance of finding quickly a solution to your task.
There are currently two ways to do sharpening and a script for the PBE specification which tries to find automatically empiricallly such constaints and encode them.</p>
<!-- toc -->
<p>Table of contents:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#forbidden-patterns"><span class="xref myst">Forbidden Patterns</span></a></p></li>
<li><p><a class="reference internal" href="#simplifying-rules"><span class="xref myst">Simplifying Rules</span></a></p>
<ul>
<li><p><a class="reference internal" href="#syntax"><span class="xref myst">Syntax</span></a></p></li>
<li><p><a class="reference internal" href="#an-example"><span class="xref myst">An Example</span></a></p></li>
<li><p><a class="reference internal" href="#automatically-generated-equations"><span class="xref myst">Automatically Generated Equations</span></a></p></li>
<li><p><a class="reference internal" href="#limits"><span class="xref myst">Limits</span></a></p></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<section id="forbidden-patterns">
<h2>Forbidden Patterns<a class="headerlink" href="#forbidden-patterns" title="Permalink to this heading"></a></h2>
<p>The first way to add constraints is when a DSL is instantiated. The second argument given is <code class="docutils literal notranslate"><span class="pre">forbidden_patterns:</span> <span class="pre">Dict[Tuple[str,</span> <span class="pre">int],</span> <span class="pre">Str[str]]</span></code>.
A key is a tuple <code class="docutils literal notranslate"><span class="pre">(name_of_parent_primitive,</span> <span class="pre">arg_no)</span></code> and gives access to the set of all primitives that cannot be directly derived for this specific argument of the <code class="docutils literal notranslate"><span class="pre">parent_primitive</span></code>.
For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">forbidden</span> <span class="o">=</span> <span class="p">{</span> 
    <span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">},</span> 
    <span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">{</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We forbid the second argument of <code class="docutils literal notranslate"><span class="pre">+</span></code> from being <code class="docutils literal notranslate"><span class="pre">+</span></code> and the first argument of <code class="docutils literal notranslate"><span class="pre">-</span></code> from being <code class="docutils literal notranslate"><span class="pre">-</span></code> or <code class="docutils literal notranslate"><span class="pre">+</span></code>.</p>
<p>This mechanism is quite powerful but does not enable to encode all constraints however it has the advantage of having no drawbacks, it can also be done within the other framework.</p>
</section>
<section id="simplifying-rules">
<h2>Simplifying Rules<a class="headerlink" href="#simplifying-rules" title="Permalink to this heading"></a></h2>
<p>More generally, we would like to remove regular tree languages from the grammar which also describes a regular tree language.
In order to do that, we define a syntax that describes a subset of regular tree language but covers the most relevant options for program synthesis.
This is quite straightforward with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">synth.pruning.constraints</span> <span class="kn">import</span> <span class="n">add_dfta_constraints</span>
<span class="kn">from</span> <span class="nn">synth.syntax.grammars</span> <span class="kn">import</span> <span class="n">UCFG</span>


<span class="n">cfg</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># your regular CFG</span>
<span class="n">my_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="c1"># a list of string that express the constraints </span>
<span class="n">sketch</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># your sketch or None if there isn&#39;t one</span>
<span class="n">ucfg</span> <span class="o">=</span> <span class="n">UCFG</span><span class="o">.</span><span class="n">from_DFTA_with_ngrams</span><span class="p">(</span>
        <span class="n">add_dfta_constraints</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">my_constraints</span><span class="p">,</span> <span class="n">global_constraint</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="mi">2</span>
    <span class="p">)</span>

<span class="c1"># You can continue as usual though since it is an UCFG instead of a CFG</span>
<span class="c1"># Det objects need to be replaced by U objects</span>
<span class="c1"># e.g.: ProbDetGrammar -&gt; ProbUGrammar, HeapSearch -&gt; UHeapSearch, ...</span>
</pre></div>
</div>
<section id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h3>
<p>Let us write <code class="docutils literal notranslate"><span class="pre">P</span></code> for the set of primitives names and variables. Rules are manipulating a set of names:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NSet</span> <span class="o">:=</span> <span class="n">f1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">fk</span> <span class="o">|</span> <span class="o">^</span><span class="n">f1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">fk</span> <span class="o">|</span> <span class="n">_</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">f1,...,fk</span></code> are from <code class="docutils literal notranslate"><span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> is the complement operator and <code class="docutils literal notranslate"><span class="pre">_</span></code> represents any symbol.
Rules have the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rules</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSet</span> <span class="n">Rules1</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="n">Rulesk</span> <span class="p">)</span> <span class="o">|</span> <span class="c1">#[NSet]&lt;=N | #[NSet]&gt;=N</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">N</span></code> are constant integers. The rule <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">g,h</span> <span class="pre">_)</span></code> specifies that for each occurrence of <code class="docutils literal notranslate"><span class="pre">f</span></code>, its first argument must be either <code class="docutils literal notranslate"><span class="pre">g</span></code> or <code class="docutils literal notranslate"><span class="pre">h</span></code>, and the second argument can be anything.
The rule <code class="docutils literal notranslate"><span class="pre">#[Var0]&gt;=1</span></code> specifies that <code class="docutils literal notranslate"><span class="pre">Var0</span></code> appears at least once.
Remark that <code class="docutils literal notranslate"><span class="pre">#[_]&lt;=10</span></code> says that the whole program has size at most 10.
Rules can be nested, for instance <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">#[g]&lt;=1</span> <span class="pre">#[h]&gt;=1</span></code> : for each occurrence of <code class="docutils literal notranslate"><span class="pre">f</span></code>, the first argument contains at most one <code class="docutils literal notranslate"><span class="pre">g</span></code>, and the second argument at least one <code class="docutils literal notranslate"><span class="pre">h</span></code>.
Rules specify locally which primitives or variables can be combined together.</p>
<p>A sketch has the same syntax as a constraint.
It specifies how the solution program should be, that is the derivations from the root, whereas constraints specify derivation anywhere in the programs.
For instance, the skecth <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">_</span> <span class="pre">g)</span></code> specifies that the program starts with <code class="docutils literal notranslate"><span class="pre">f</span></code> and that the second argument of that particular <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
</section>
<section id="an-example">
<h3>An Example<a class="headerlink" href="#an-example" title="Permalink to this heading"></a></h3>
<p>Let us consider the grammar of Boolean formulas over the binary operators <code class="docutils literal notranslate"><span class="pre">And</span></code>, <code class="docutils literal notranslate"><span class="pre">Or</span></code> and unary <code class="docutils literal notranslate"><span class="pre">Not</span></code>, with Boolean variables <code class="docutils literal notranslate"><span class="pre">Var0</span></code>, <code class="docutils literal notranslate"><span class="pre">Var1</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="o">-&gt;</span> <span class="n">And</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">|</span> <span class="n">Or</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">|</span> <span class="n">Not</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span> <span class="o">|</span> <span class="n">Var0</span> <span class="o">|</span> <span class="n">Var1</span>
</pre></div>
</div>
<p>Clearly, this grammar generates a lot of redundant programs. Let us specify some rules in order to enforce that all programs are in conjunctive normal form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Or ¬And ¬And ;
Not ¬{And, Or}
</pre></div>
</div>
<p>The first rule specifies that <code class="docutils literal notranslate"><span class="pre">And</span></code> cannot be an argument of <code class="docutils literal notranslate"><span class="pre">Or</span></code> and the second one that <code class="docutils literal notranslate"><span class="pre">And</span></code> and <code class="docutils literal notranslate"><span class="pre">Or</span></code> cannot be arguments of <code class="docutils literal notranslate"><span class="pre">Not</span></code>. The output of a compilation algorithm using these two rules could be the following grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bool1</span> <span class="o">-&gt;</span> <span class="n">And</span><span class="p">(</span><span class="n">bool1</span><span class="p">,</span> <span class="n">bool1</span> <span class="p">)</span> <span class="o">|</span> <span class="n">Or</span><span class="p">(</span><span class="n">bool2</span> <span class="p">,</span> <span class="n">bool2</span> <span class="p">)</span> <span class="o">|</span> <span class="n">Not</span><span class="p">(</span><span class="n">bool3</span> <span class="p">)</span> <span class="o">|</span> <span class="n">Var0</span> <span class="o">|</span> <span class="n">Var1</span>
<span class="n">bool2</span> <span class="o">-&gt;</span> <span class="n">Or</span><span class="p">(</span><span class="n">bool2</span> <span class="p">,</span> <span class="n">bool2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Not</span><span class="p">(</span><span class="n">bool3</span><span class="p">)</span> <span class="o">|</span> <span class="n">Var0</span> <span class="o">|</span> <span class="n">Var1</span>
<span class="n">bool3</span> <span class="o">-&gt;</span> <span class="n">Not</span><span class="p">(</span><span class="n">bool3</span><span class="p">)</span> <span class="o">|</span> <span class="n">Var0</span> <span class="o">|</span> <span class="n">Var1</span>
</pre></div>
</div>
<p>There are still a lot of equivalent programs generated by this grammar. One could consider the following rules further reducing symmetries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>And ¬And _ ;
Or ¬{Or, And} ¬And ;
Not ¬{And, Or}
</pre></div>
</div>
<p>It ensures conjunctive normal form but also that both <code class="docutils literal notranslate"><span class="pre">And</span></code> and <code class="docutils literal notranslate"><span class="pre">Or</span></code> are associated to the right: in particular, the formula <code class="docutils literal notranslate"><span class="pre">And(And(φ1</span> <span class="pre">,</span> <span class="pre">φ2),</span> <span class="pre">φ3)</span></code> is replaced
by <code class="docutils literal notranslate"><span class="pre">And(φ1</span> <span class="pre">,</span> <span class="pre">And(φ2</span> <span class="pre">,</span> <span class="pre">φ3))</span></code>.</p>
</section>
<section id="automatically-generated-equations">
<h3>Automatically Generated Equations<a class="headerlink" href="#automatically-generated-equations" title="Permalink to this heading"></a></h3>
<p>Since writing rules can be tedious, even more so for large grammars, we propose
an automated process for generating valid equations:</p>
<ol class="arabic simple">
<li><p>We enumerate all programs up to some fixed depth (in practice, 3 or 4);</p></li>
<li><p>We check for program equivalence amongst all generated programs;</p></li>
<li><p>For each equivalence class of programs, we choose as representative the small-
est program of that class: the goal is to find rules rejecting all non represen-
tative programs;</p></li>
<li><p>We enumerate rules and for each check whether they are useful, meaning
reject only (new) non representative programs.
Note that program equivalence may be hard to solve; in practice we evaluate the
programs on a set of inputs that is either sampled or scrapped from a dataset
and declare two programs equivalent if their outputs coincide on them.</p></li>
</ol>
<p>ProgSynth provides for some type of specifications such as PBE a script <code class="docutils literal notranslate"><span class="pre">dsl_analyser.py</span></code> such a tool.
The script works by either reproducing the distriution from a given dataset or just taking inputs from a given dataset, this enables it to produce inputs to test programs.
It then evaluates programs up to depth 2 of the grammar and builds sets of semantically equivalent programs with respect to this set of inputs.
Some of these programs can then be removed from the grammar.
The script produces two files:</p>
<ul class="simple">
<li><p>a python file containing all constraints that were automatically produced;</p></li>
<li><p>a JSON file containing all semantically equivalent classes of programs et depth 2.</p></li>
</ul>
</section>
<section id="limits">
<h3>Limits<a class="headerlink" href="#limits" title="Permalink to this heading"></a></h3>
<p>The design of our syntax was guided by simplicity; although expressive enough for most use cases, it could be extended.
Indeed, some natural rules cannot be expressed, for instance forbidding the pattern <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">a</span> <span class="pre">b)</span></code>, when there is an occurrence of <code class="docutils literal notranslate"><span class="pre">f</span></code> where the first argument is <code class="docutils literal notranslate"><span class="pre">a</span></code> and the second argument is <code class="docutils literal notranslate"><span class="pre">b</span></code>.
To put this remark in a wider perspective: we note that all simplifyig rules defined in our syntax induce regular tree languages, but conversely that some regular tree languages, such as ‘trees without the pattern <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">a</span> <span class="pre">b)</span></code>’, cannot be defined in our syntax.
However, with some small tweaking one can directly give an deterministic bottom-up tree automaton and use it as if it were a rule.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="examples_pbe.html" class="btn btn-neutral float-left" title="PBE Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="contributing.html" class="btn btn-neutral float-right" title="Contributing to ProgSynth" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Nathanaël Fijalkow &amp; Théo Matricon.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>